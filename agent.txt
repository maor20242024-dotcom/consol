

## خطة دمج حسابات Instagram و WhatsApp في IMPERIUM GATE

ستتضمن هذه الخطة:
1.  **المتطلبات الأساسية (Prerequisites):** ما الذي يجب أن يتوفر قبل البدء.
2.  **تحديثات قاعدة البيانات (Database Schema Updates):** الجداول الجديدة أو التعديلات المطلوبة لتخزين معلومات الربط.
3.  **واجهات برمجة التطبيقات (API Routes) في Backend:** كيفية التعامل مع المصادقة والبيانات الواردة والصادرة.
4.  **واجهة المستخدم (Frontend UI) في صفحة الإعدادات:** كيف يمكن للمستخدم ربط وإدارة حساباته.
5.  **الذكاء الاصطناعي والتأثير التسويقي (AI & Marketing Impact):** كيف ستستغل Imperium Gate هذه التكاملات.
6.  **الأمان (Security):** نقاط هامة لضمان أمان البيانات.

---

### 1. المتطلبات الأساسية (Prerequisites)

قبل البدء في الكود، يجب التأكد من توفر التالي:

*   **حساب Meta Developer:** لإنشاء تطبيقات Facebook/Instagram والحصول على معرفات التطبيق والمفاتيح السرية.
*   **حساب Instagram Business/Creator:** الحسابات الشخصية لا تدعم Graph API الكامل.
*   **صفحة Facebook (Page):** يجب أن تكون مرتبطة بحساب Instagram Business.
*   **حساب WhatsApp Business Platform:** للوصول إلى WhatsApp Business API (يتطلب مراجعة وتحقق من Meta).
*   **Meta Business Manager:** لإدارة جميع الأصول (الصفحات، حسابات الإعلانات، WhatsApp Business Account).
*   **Webhook URL عام (Publicly Accessible Webhook URL):** مطلوب لتلقي الإشعارات من Meta (مثل الرسائل الجديدة على Instagram DM أو WhatsApp).

---

### 2. تحديثات قاعدة البيانات (Database Schema Updates)

سنحتاج إلى جداول جديدة لتخزين بيانات حسابات Instagram و WhatsApp المرتبطة بكل مستخدم.

#### أ. تعديل ملف `prisma/schema.prisma`

سنفترض وجود نموذج `User` أو `Profile` يمثل المستخدم الذي يربط حساباته.

```prisma
// FILE: prisma/schema.prisma
// ... existing models

model User { // Or Profile, depending on your authentication setup
  id                 String    @id @default(uuid())
  email              String    @unique
  name               String?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  instagramAccounts InstagramAccount[]
  whatsappAccounts  WhatsAppAccount[]
  // Other user fields
}

// Model for connected Instagram Business Accounts
model InstagramAccount {
  id                    String    @id @default(uuid())
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Meta-specific IDs
  igUserId              String    @unique // Instagram Business Account ID from Meta
  fbPageId              String    @unique // Connected Facebook Page ID
  
  // Account details
  name                  String
  username              String    @unique
  profilePictureUrl     String?
  
  // OAuth Token (CRITICAL: MUST BE ENCRYPTED IN PRODUCTION DB)
  accessToken           String // Long-lived access token for Meta Graph API
  expiresAt             DateTime? // When the access token expires (usually never for long-lived, but good to store)
  
  // Status
  status                String    @default("connected") // e.g., "connected", "disconnected", "error"
  lastSyncedAt          DateTime?
  
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  instagramDMs          InstagramDM[]
  instagramPosts        InstagramPost[] // For organic posts integration
}

// Model for connected WhatsApp Business API Accounts
model WhatsAppAccount {
  id                    String    @id @default(uuid())
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Meta-specific IDs
  phoneNumberId         String    @unique // WhatsApp Phone Number ID (from Meta)
  wabaId                String    // WhatsApp Business Account ID
  
  // Account details
  phoneNumber           String    @unique // The actual phone number
  name                  String?   // Display name
  
  // Access Token (CRITICAL: MUST BE ENCRYPTED IN PRODUCTION DB)
  accessToken           String    // Access token for WhatsApp Business API
  
  // Webhook settings (optional, can be managed by the platform)
  webhookVerified       Boolean   @default(false)
  
  // Status
  status                String    @default("connected") // e.g., "connected", "disconnected", "error"
  lastSyncedAt          DateTime?

  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  whatsappMessages      WhatsAppMessage[] // For inbound/outbound messages
}

// Example for storing Instagram DMs
model InstagramDM {
  id                    String    @id @default(uuid())
  instagramAccountId    String
  instagramAccount      InstagramAccount @relation(fields: [instagramAccountId], references: [id], onDelete: Cascade)

  senderId              String
  recipientId           String
  message               String
  isRead                Boolean   @default(false)
  sentAt                DateTime  @default(now())
  
  // Potentially link to Lead/CRM
  leadId                String?
  lead                  Lead?     @relation(fields: [leadId], references: [id])
}

// Example for storing WhatsApp Messages
model WhatsAppMessage {
  id                    String    @id @default(uuid())
  whatsappAccountId     String
  whatsappAccount       WhatsAppAccount @relation(fields: [whatsappAccountId], references: [id], onDelete: Cascade)

  senderId              String
  recipientId           String
  message               String
  isRead                Boolean   @default(false)
  sentAt                DateTime  @default(now())

  // Potentially link to Lead/CRM
  leadId                String?
  lead                  Lead?     @relation(fields: [leadId], references: [id])
}

// ... existing InstagramCampaign, InstagramAd, AdAsset, AdPerformance, Lead models
```

**بعد تحديث `schema.prisma`، تذكر تشغيل:**
`npx prisma migrate dev --name add_instagram_whatsapp_integrations`
`npx prisma generate`

---

### 3. واجهات برمجة التطبيقات (API Routes) في Backend

سنحتاج إلى API routes للتعامل مع المصادقة (Meta OAuth) وتخزين الـ tokens ومعالجة الـ Webhooks.

#### أ. تهيئة المتغيرات البيئية (Environment Variables)

أضف هذه المتغيرات إلى ملف `.env.local` الخاص بك:

```env
# Meta (Facebook/Instagram/WhatsApp) Integration
META_APP_ID=YOUR_META_APP_ID
META_APP_SECRET=YOUR_META_APP_SECRET
NEXT_PUBLIC_META_REDIRECT_URI=http://localhost:8080/api/integrations/instagram/callback # Update for production
META_API_VERSION=v19.0 # Or the latest version

# Encryption Key for Access Tokens (IMPORTANT FOR SECURITY)
ACCESS_TOKEN_ENCRYPTION_KEY=YOUR_STRONG_ENCRYPTION_KEY_32_CHARS # Generate a random 32-character string
```

#### ب. دالة التشفير/فك التشفير (Encryption/Decryption Utility)

**(`lib/encryption.ts`)**: يجب تشفير الـ Access Tokens قبل تخزينها في قاعدة البيانات وفك تشفيرها عند الحاجة.

```typescript
// FILE: app2/lib/encryption.ts
import crypto from 'crypto';

const algorithm = 'aes-256-cbc';
const IV_LENGTH = 16; // For AES, this is always 16 bytes

if (!process.env.ACCESS_TOKEN_ENCRYPTION_KEY) {
  console.warn("ACCESS_TOKEN_ENCRYPTION_KEY is not set. Encryption will not work.");
}

const ENCRYPTION_KEY = Buffer.from(process.env.ACCESS_TOKEN_ENCRYPTION_KEY || 'default-key-for-dev-only-32', 'utf8'); // 32 bytes for aes-256

export function encrypt(text: string): string {
  if (ENCRYPTION_KEY.length !== 32) {
    console.error("Encryption key must be 32 bytes for AES-256-CBC. Current length:", ENCRYPTION_KEY.length);
    throw new Error('Encryption key must be 32 bytes.');
  }
  
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv(algorithm, ENCRYPTION_KEY, iv);
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return iv.toString('hex') + ':' + encrypted;
}

export function decrypt(text: string): string {
  if (ENCRYPTION_KEY.length !== 32) {
    console.error("Encryption key must be 32 bytes for AES-256-CBC. Current length:", ENCRYPTION_KEY.length);
    throw new Error('Encryption key must be 32 bytes.');
  }

  const textParts = text.split(':');
  if (textParts.length !== 2) {
    throw new Error('Invalid encrypted text format.');
  }

  const iv = Buffer.from(textParts[0], 'hex');
  const encryptedText = Buffer.from(textParts[1], 'hex');
  const decipher = crypto.createDecipheriv(algorithm, ENCRYPTION_KEY, iv);
  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}
```

#### ج. API لربط Instagram (`app/api/integrations/instagram/connect/route.ts`)

هذا الـ API سيبدأ عملية Meta OAuth.

```typescript
// FILE: app2/app/api/integrations/instagram/connect/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const userId = searchParams.get('userId'); // Get current user ID to link account

  if (!userId) {
    return NextResponse.json({ error: 'User ID is required for Instagram connection' }, { status: 400 });
  }

  const metaAppId = process.env.META_APP_ID;
  const nextPublicMetaRedirectUri = process.env.NEXT_PUBLIC_META_REDIRECT_URI;
  const metaApiVersion = process.env.META_API_VERSION || 'v19.0';

  if (!metaAppId || !nextPublicMetaRedirectUri) {
    console.error('Missing Meta App ID or Redirect URI environment variables.');
    return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });
  }

  // Permissions needed:
  // pages_show_list: To get a list of Facebook Pages that the user manages.
  // instagram_basic: To read the Instagram Business Account profile.
  // instagram_manage_comments: To manage comments (for AI assistant).
  // instagram_manage_insights: To read insights (for analytics).
  // instagram_content_publish: To publish posts (if needed).
  // pages_read_engagement: To read content on pages.
  // business_management: To access business assets.
  // instagram_manage_messages: To read and reply to DMs.
  const scope = [
    'instagram_basic',
    'instagram_manage_comments',
    'instagram_manage_insights',
    'instagram_content_publish',
    'pages_show_list',
    'pages_read_engagement',
    'business_management',
    'instagram_manage_messages', // For DMs
  ].join(',');

  const dialogUrl = `https://www.facebook.com/${metaApiVersion}/dialog/oauth?` +
    `client_id=${metaAppId}&` +
    `redirect_uri=${nextPublicMetaRedirectUri}&` +
    `scope=${scope}&` +
    `state=${userId}`; // Pass userId through state to link back

  return NextResponse.json({ redirectUrl: dialogUrl });
}
```

#### د. API لمعالجة رد Instagram OAuth (`app/api/integrations/instagram/callback/route.ts`)

هذا الـ API سيتلقى الرد من Meta بعد مصادقة المستخدم، ويحصل على الـ Access Token ويحفظه.

```typescript
// FILE: app2/app/api/integrations/instagram/callback/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { encrypt } from '@/lib/encryption'; // Import encryption utility
import { createAdminClient } from '@/lib/supabase'; // Using admin client for user ID access

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const code = searchParams.get('code');
  const state = searchParams.get('state'); // This is our userId
  const error = searchParams.get('error');

  if (error) {
    console.error('Meta OAuth Error:', error, searchParams.get('error_description'));
    // Redirect to an error page or settings page with error message
    return NextResponse.redirect(new URL(`/error?message=Meta OAuth failed: ${error}`, req.url));
  }

  if (!code || !state) {
    return NextResponse.redirect(new URL('/error?message=Missing OAuth code or state', req.url));
  }

  const userId = state;
  const metaAppId = process.env.META_APP_ID;
  const metaAppSecret = process.env.META_APP_SECRET;
  const nextPublicMetaRedirectUri = process.env.NEXT_PUBLIC_META_REDIRECT_URI;
  const metaApiVersion = process.env.META_API_VERSION || 'v19.0';

  if (!metaAppId || !metaAppSecret || !nextPublicMetaRedirectUri) {
    console.error('Missing Meta App ID, App Secret or Redirect URI environment variables.');
    return NextResponse.redirect(new URL('/error?message=Server configuration error', req.url));
  }

  try {
    // 1. Exchange code for a short-lived access token
    const tokenResponse = await fetch(
      `https://graph.facebook.com/${metaApiVersion}/oauth/access_token?` +
      `client_id=${metaAppId}&` +
      `client_secret=${metaAppSecret}&` +
      `code=${code}&` +
      `redirect_uri=${nextPublicMetaRedirectUri}`,
      { method: 'GET' }
    );
    const tokenData = await tokenResponse.json();

    if (tokenData.error) {
      console.error('Failed to get short-lived token:', tokenData.error);
      return NextResponse.redirect(new URL(`/error?message=Failed to authenticate with Meta: ${tokenData.error.message}`, req.url));
    }

    const shortLivedAccessToken = tokenData.access_token;

    // 2. Exchange short-lived token for a long-lived access token
    const longLivedTokenResponse = await fetch(
      `https://graph.facebook.com/${metaApiVersion}/oauth/access_token?` +
      `grant_type=fb_exchange_token&` +
      `client_id=${metaAppId}&` +
      `client_secret=${metaAppSecret}&` +
      `fb_exchange_token=${shortLivedAccessToken}`,
      { method: 'GET' }
    );
    const longLivedTokenData = await longLivedTokenResponse.json();

    if (longLivedTokenData.error) {
      console.error('Failed to get long-lived token:', longLivedTokenData.error);
      return NextResponse.redirect(new URL(`/error?message=Failed to get long-lived Meta token: ${longLivedTokenData.error.message}`, req.url));
    }

    const longLivedAccessToken = longLivedTokenData.access_token;

    // 3. Get Facebook Pages user manages
    const pagesResponse = await fetch(
      `https://graph.facebook.com/${metaApiVersion}/me/accounts?access_token=${longLivedAccessToken}`,
      { method: 'GET' }
    );
    const pagesData = await pagesResponse.json();

    if (pagesData.error) {
        console.error('Failed to get Facebook Pages:', pagesData.error);
        return NextResponse.redirect(new URL(`/error?message=Failed to retrieve Facebook Pages: ${pagesData.error.message}`, req.url));
    }

    // Filter for pages connected to Instagram Business Accounts
    let connectedIgAccount = null;
    for (const page of pagesData.data) {
        const instagramBusinessAccountResponse = await fetch(
            `https://graph.facebook.com/${metaApiVersion}/${page.id}?fields=instagram_business_account&access_token=${longLivedAccessToken}`,
            { method: 'GET' }
        );
        const igData = await instagramBusinessAccountResponse.json();

        if (igData.instagram_business_account) {
            // Get Instagram Business Account details
            const igAccountDetailsResponse = await fetch(
                `https://graph.facebook.com/${metaApiVersion}/${igData.instagram_business_account.id}?fields=id,username,name,profile_picture_url&access_token=${longLivedAccessToken}`,
                { method: 'GET' }
            );
            const igAccountDetails = await igAccountDetailsResponse.json();

            connectedIgAccount = {
                igUserId: igAccountDetails.id,
                fbPageId: page.id,
                name: igAccountDetails.name,
                username: igAccountDetails.username,
                profilePictureUrl: igAccountDetails.profile_picture_url,
            };
            break; // Found one, assume one Instagram account per page for now
        }
    }

    if (!connectedIgAccount) {
        return NextResponse.redirect(new URL(`/settings?tab=integrations&error=No Instagram Business Account found linked to your Facebook Pages.`, req.url));
    }

    // 4. Save the long-lived access token and Instagram account details to your database
    const encryptedAccessToken = encrypt(longLivedAccessToken); // Encrypt the token

    await prisma.instagramAccount.upsert({
      where: { igUserId: connectedIgAccount.igUserId },
      update: {
        accessToken: encryptedAccessToken,
        fbPageId: connectedIgAccount.fbPageId,
        name: connectedIgAccount.name,
        username: connectedIgAccount.username,
        profilePictureUrl: connectedIgAccount.profilePictureUrl,
        userId: userId, // Ensure it's linked to the current user
        status: 'connected',
      },
      create: {
        igUserId: connectedIgAccount.igUserId,
        fbPageId: connectedIgAccount.fbPageId,
        name: connectedIgAccount.name,
        username: connectedIgAccount.username,
        profilePictureUrl: connectedIgAccount.profilePictureUrl,
        accessToken: encryptedAccessToken,
        userId: userId,
        status: 'connected',
      },
    });

    // Redirect to settings page with success message
    return NextResponse.redirect(new URL(`/settings?tab=integrations&success=Instagram account connected successfully!`, req.url));

  } catch (err: any) {
    console.error('Instagram Integration Error:', err);
    return NextResponse.redirect(new URL(`/error?message=Internal server error during Instagram connection: ${err.message}`, req.url));
  }
}
```

#### هـ. API لربط WhatsApp (Manual/API Key based) (`app/api/integrations/whatsapp/connect/route.ts`)

دمج WhatsApp Business API عادة ما يكون يدوياً أكثر، حيث يقوم المستخدم بإنشاء تطبيق و WABA في Meta Business Manager، ثم يوفر الـ Phone Number ID، WABA ID، و Access Token لمنصتك. أنت بعد ذلك تقوم بتسجيل الـ Webhooks.

```typescript
// FILE: app2/app/api/integrations/whatsapp/connect/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { encrypt } from '@/lib/encryption';
import { z } from 'zod';

const whatsappConnectSchema = z.object({
  userId: z.string().min(1, 'User ID is required'),
  phoneNumberId: z.string().min(1, 'Phone Number ID is required'),
  wabaId: z.string().min(1, 'WhatsApp Business Account ID is required'),
  phoneNumber: z.string().min(1, 'Phone number is required'),
  accessToken: z.string().min(1, 'Access Token is required'),
  name: z.string().optional(),
});

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const validatedData = whatsappConnectSchema.safeParse(body);

    if (!validatedData.success) {
      return NextResponse.json({ error: validatedData.error.errors.map(e => e.message).join(', ') }, { status: 400 });
    }

    const { userId, phoneNumberId, wabaId, phoneNumber, accessToken, name } = validatedData.data;

    const encryptedAccessToken = encrypt(accessToken);

    // Register webhook with Meta (This is a simplified representation)
    // In a real scenario, you'd make an API call to Meta to subscribe to events
    // and verify your webhook endpoint.
    // Example (conceptual):
    // const webhookRegisterResponse = await fetch(`https://graph.facebook.com/${process.env.META_API_VERSION || 'v19.0'}/${wabaId}/subscribed_apps`, {
    //   method: 'POST',
    //   headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' },
    //   body: JSON.stringify({
    //     webhook_url: `${process.env.NEXT_PUBLIC_BASE_URL}/api/webhooks/whatsapp`,
    //     verify_token: process.env.WHATSAPP_WEBHOOK_VERIFY_TOKEN,
    //     fields: ['messages', 'message_template_status_update', 'messaging_postbacks'],
    //   }),
    // });
    // if (!webhookRegisterResponse.ok) {
    //   console.error('Failed to register WhatsApp webhook:', await webhookRegisterResponse.json());
    //   return NextResponse.json({ error: 'Failed to register WhatsApp webhook.' }, { status: 500 });
    // }
    console.log(`[WHATSAPP INTEGRATION] Webhook registration simulated for WABA ID: ${wabaId}`);


    await prisma.whatsappAccount.upsert({
      where: { phoneNumberId: phoneNumberId },
      update: {
        wabaId: wabaId,
        phoneNumber: phoneNumber,
        name: name,
        accessToken: encryptedAccessToken,
        userId: userId,
        status: 'connected',
        webhookVerified: true, // Assuming success
      },
      create: {
        phoneNumberId: phoneNumberId,
        wabaId: wabaId,
        phoneNumber: phoneNumber,
        name: name,
        accessToken: encryptedAccessToken,
        userId: userId,
        status: 'connected',
        webhookVerified: true,
      },
    });

    return NextResponse.json({ success: true, message: 'WhatsApp account connected successfully!' });

  } catch (err: any) {
    console.error('WhatsApp Integration Error:', err);
    return NextResponse.json({ error: `Internal server error during WhatsApp connection: ${err.message}` }, { status: 500 });
  }
}
```

#### و. API لمعالجة Webhooks من Meta (`app/api/webhooks/meta/route.ts`)

هذا الـ API سيتلقى جميع إشعارات الـ Webhook من Meta، بما في ذلك رسائل Instagram DM ورسائل WhatsApp.

```typescript
// FILE: app2/app/api/webhooks/meta/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { decrypt } from '@/lib/encryption'; // For token decryption if needed here
import crypto from 'crypto';

// Replace with your actual Meta App Secret
const META_APP_SECRET = process.env.META_APP_SECRET;
const WHATSAPP_WEBHOOK_VERIFY_TOKEN = process.env.WHATSAPP_WEBHOOK_VERIFY_TOKEN; // Used for initial webhook verification

// GET for Webhook Verification (Meta will send this when setting up webhook)
export async function GET(req: NextRequest) {
    const { searchParams } = new URL(req.url);
    const mode = searchParams.get('hub.mode');
    const token = searchParams.get('hub.verify_token');
    const challenge = searchParams.get('hub.challenge');

    if (mode === 'subscribe' && token === WHATSAPP_WEBHOOK_VERIFY_TOKEN) {
        console.log('Webhook verified successfully!');
        return new NextResponse(challenge, { status: 200 });
    } else {
        console.error('Webhook verification failed.');
        return new NextResponse('Verification token mismatch', { status: 403 });
    }
}

// POST for handling incoming webhook events
export async function POST(req: NextRequest) {
  try {
    const rawBody = await req.text(); // Get raw body to verify signature
    const signature = req.headers.get('x-hub-signature-256');

    // 1. Verify webhook signature (CRITICAL for security)
    if (!META_APP_SECRET) {
        console.warn('META_APP_SECRET not set. Skipping webhook signature verification. THIS IS INSECURE IN PRODUCTION!');
    } else if (signature) {
      const hmac = crypto.createHmac('sha256', META_APP_SECRET);
      hmac.update(rawBody);
      const expectedSignature = `sha256=${hmac.digest('hex')}`;
      if (signature !== expectedSignature) {
        console.error('Webhook signature mismatch. Request origin may be spoofed.');
        return NextResponse.json({ error: 'Unauthorized: Signature mismatch' }, { status: 403 });
      }
    } else {
        console.warn('Webhook signature missing. Proceeding without verification. THIS IS INSECURE IN PRODUCTION!');
    }

    const data = JSON.parse(rawBody);
    console.log('[META WEBHOOK RECEIVED]', JSON.stringify(data, null, 2));

    // 2. Process Instagram Direct Messages
    if (data.object === 'instagram' && data.entry) {
        for (const entry of data.entry) {
            if (entry.messaging) {
                for (const message of entry.messaging) {
                    if (message.message) {
                        const igAccountId = entry.id; // The Instagram Business Account ID
                        const senderId = message.sender.id;
                        const messageText = message.message.text;

                        // Find the connected Instagram account
                        const connectedIg = await prisma.instagramAccount.findUnique({
                            where: { igUserId: igAccountId },
                            select: { id: true, userId: true },
                        });

                        if (connectedIg) {
                            await prisma.instagramDM.create({
                                data: {
                                    instagramAccountId: connectedIg.id,
                                    senderId: senderId,
                                    recipientId: igAccountId, // The platform's IG account
                                    message: messageText,
                                    // Potentially: link to a Lead or create a new one based on senderId
                                    // You would need to fetch sender's profile info from IG API using their ID
                                }
                            });
                            console.log(`[INSTAGRAM DM] Saved from ${senderId} to IG Account ${igAccountId}: ${messageText}`);
                            // Trigger AI Assistant response here
                            // await AI_ASSISTANT.processInstagramDM(connectedIg.userId, senderId, messageText);
                        }
                    }
                }
            }
        }
    }

    // 3. Process WhatsApp Messages
    if (data.object === 'whatsapp_business_account' && data.entry) {
        for (const entry of data.entry) {
            if (entry.changes) {
                for (const change of entry.changes) {
                    if (change.field === 'messages' && change.value) {
                        const phoneNumberId = change.value.metadata.phone_number_id;
                        const wabaId = change.value.metadata.whatsapp_business_account_id;

                        for (const message of change.value.messages) {
                            if (message.type === 'text') {
                                const senderId = message.from; // User's phone number
                                const messageText = message.text.body;

                                const connectedWhatsapp = await prisma.whatsappAccount.findUnique({
                                    where: { phoneNumberId: phoneNumberId },
                                    select: { id: true, userId: true },
                                });

                                if (connectedWhatsapp) {
                                    await prisma.whatsappMessage.create({
                                        data: {
                                            whatsappAccountId: connectedWhatsapp.id,
                                            senderId: senderId,
                                            recipientId: phoneNumberId, // The platform's WhatsApp number
                                            message: messageText,
                                            // Link to Lead or create new
                                        }
                                    });
                                    console.log(`[WHATSAPP MESSAGE] Saved from ${senderId} to WhatsApp Account ${phoneNumberId}: ${messageText}`);
                                    // Trigger AI Assistant response here
                                    // await AI_ASSISTANT.processWhatsAppMessage(connectedWhatsapp.userId, senderId, messageText);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return NextResponse.json({ success: true }, { status: 200 });
  } catch (err: any) {
    console.error('Webhook processing error:', err);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```

---

### 4. واجهة المستخدم (Frontend UI) في صفحة الإعدادات (`app/[locale]/settings/page.tsx`)

سنضيف تبويباً جديداً لـ "Integrations" حيث يمكن للمستخدم ربط وإدارة حساباته.

#### أ. تحديث `messages/en.json` و `messages/ar.json`

أضف المفاتيح التالية:

```json
// Example for en.json
{
  // ... other keys
  "settings": "Settings",
  "Settings": {
    // ... existing settings keys
    "integrations": "Integrations",
    "manageIntegrations": "Manage connected social media and communication accounts.",
    "instagramIntegration": "Instagram Integration",
    "connectInstagram": "Connect Instagram",
    "instagramConnected": "Instagram Business Account Connected",
    "instagramDisconnected": "Instagram Not Connected",
    "disconnectInstagram": "Disconnect Instagram",
    "whatsappIntegration": "WhatsApp Integration",
    "connectWhatsapp": "Connect WhatsApp",
    "whatsappConnected": "WhatsApp Business API Connected",
    "whatsappDisconnected": "WhatsApp Not Connected",
    "disconnectWhatsapp": "Disconnect WhatsApp",
    "phoneNumberId": "Phone Number ID",
    "wabaId": "WhatsApp Business Account ID",
    "whatsappAccessToken": "WhatsApp Access Token",
    "whatsappNumber": "WhatsApp Number (e.g. +9715XXXXXXX)",
    "whatsappDisplayName": "Display Name (Optional)",
    "saveWhatsappConnection": "Save WhatsApp Connection",
    "whatsappConnectInstructions": "To connect WhatsApp, you need to set up WhatsApp Business API through Meta Business Manager. Provide the required IDs and Access Token below.",
    "connectionStatus": "Connection Status:",
    "connected": "Connected",
    "notConnected": "Not Connected"
  },
  "error": "Error",
  "success": "Success",
  "instagramConnectSuccess": "Instagram account connected successfully!",
  "whatsappConnectSuccess": "WhatsApp account connected successfully!"
}
```

#### ب. تعديل `app/[locale]/settings/page.tsx`

```tsx
// FILE: app2/app/[locale]/settings/page.tsx
"use client";

import { useState, useEffect } from "react";
import { useTranslations } from "next-intl";
import { useRouter, usePathname, useSearchParams } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Bell, Lock, Globe, User, Zap, CreditCard, Shield, Instagram, MessageCircle } from "lucide-react";
import dynamic from "next/dynamic";
import { PageShell } from "@/components/page-shell";
import { useToast } from "@/hooks/use-toast"; // Import useToast

const FloatingDots = dynamic(
    () => import("@/components/FloatingDots").then((m) => m.FloatingDots),
    { ssr: false }
);

export default function SettingsPage() {
    const t = useTranslations("Settings");
    const commonT = useTranslations(); // For general translations like "error", "success"
    const router = useRouter();
    const pathname = usePathname();
    const searchParams = useSearchParams();
    const locale = pathname.split("/")[1] || "en";
    const { toast } = useToast(); // Initialize useToast

    const [settings, setSettings] = useState({
        email: "admin@imperium.local",
        phone: "+971501234567",
        language: locale,
        timezone: "GST",
        notifications: {
            email: true,
            sms: true,
            push: true,
        },
        privacy: {
            profile: "public",
            analytics: true,
            dataCollection: true,
        },
    });

    const [instagramAccount, setInstagramAccount] = useState<any>(null);
    const [whatsappAccount, setWhatsappAccount] = useState<any>({
        phoneNumberId: '',
        wabaId: '',
        accessToken: '',
        phoneNumber: '',
        name: ''
    });
    const [loadingIntegrations, setLoadingIntegrations] = useState(true);
    const [currentUser, setCurrentUser] = useState<any>(null); // To store current Supabase user

    useEffect(() => {
        // Handle OAuth redirect messages
        const successMessage = searchParams.get('success');
        const errorMessage = searchParams.get('error');
        if (successMessage) {
            toast({ title: commonT("success"), description: successMessage, variant: "default" });
            router.replace(pathname, undefined); // Clean URL
        }
        if (errorMessage) {
            toast({ title: commonT("error"), description: errorMessage, variant: "destructive" });
            router.replace(pathname, undefined); // Clean URL
        }

        // Fetch current user and integrations
        const fetchUserDataAndIntegrations = async () => {
            setLoadingIntegrations(true);
            try {
                // Fetch current Supabase session
                const { supabase } = await import("@/lib/supabase");
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) {
                    router.push(`/${locale}/login`);
                    return;
                }
                setCurrentUser(session.user);

                // Fetch Instagram Account
                const igResponse = await fetch(`/api/integrations/instagram?userId=${session.user.id}`);
                const igData = await igResponse.json();
                if (igData.success && igData.accounts.length > 0) {
                    setInstagramAccount(igData.accounts[0]);
                } else {
                    setInstagramAccount(null);
                }

                // Fetch WhatsApp Account
                const whatsappResponse = await fetch(`/api/integrations/whatsapp?userId=${session.user.id}`);
                const whatsappData = await whatsappResponse.json();
                if (whatsappData.success && whatsappData.accounts.length > 0) {
                    setWhatsappAccount(whatsappData.accounts[0]);
                } else {
                    // Reset to empty for form if no account
                    setWhatsappAccount({
                        phoneNumberId: '',
                        wabaId: '',
                        accessToken: '',
                        phoneNumber: '',
                        name: ''
                    });
                }

            } catch (error) {
                console.error("Failed to fetch user data or integrations:", error);
                toast({ title: commonT("error"), description: "Failed to load integrations.", variant: "destructive" });
            } finally {
                setLoadingIntegrations(false);
            }
        };

        fetchUserDataAndIntegrations();
    }, [searchParams, locale, router, toast, commonT, pathname]);

    // Handle Instagram Connection
    const handleConnectInstagram = async () => {
        if (!currentUser) {
            toast({ title: commonT("error"), description: "User not authenticated.", variant: "destructive" });
            return;
        }
        try {
            const response = await fetch(`/api/integrations/instagram/connect?userId=${currentUser.id}`);
            const data = await response.json();
            if (data.redirectUrl) {
                router.push(data.redirectUrl);
            } else {
                toast({ title: commonT("error"), description: "Failed to initiate Instagram connection.", variant: "destructive" });
            }
        } catch (error) {
            console.error("Error initiating Instagram connection:", error);
            toast({ title: commonT("error"), description: "An error occurred during Instagram connection.", variant: "destructive" });
        }
    };

    // Handle Instagram Disconnection
    const handleDisconnectInstagram = async () => {
        if (!instagramAccount) return;
        try {
            const response = await fetch(`/api/integrations/instagram/disconnect/${instagramAccount.id}`, {
                method: 'DELETE'
            });
            const data = await response.json();
            if (data.success) {
                toast({ title: commonT("success"), description: data.message, variant: "default" });
                setInstagramAccount(null);
            } else {
                toast({ title: commonT("error"), description: data.error, variant: "destructive" });
            }
        } catch (error) {
            console.error("Error disconnecting Instagram:", error);
            toast({ title: commonT("error"), description: "An error occurred during Instagram disconnection.", variant: "destructive" });
        }
    };

    // Handle WhatsApp Connection (Manual input)
    const handleSaveWhatsappConnection = async () => {
        if (!currentUser) {
            toast({ title: commonT("error"), description: "User not authenticated.", variant: "destructive" });
            return;
        }
        // Basic validation for manual input
        if (!whatsappAccount.phoneNumberId || !whatsappAccount.wabaId || !whatsappAccount.accessToken || !whatsappAccount.phoneNumber) {
            toast({ title: commonT("error"), description: "Please fill all required WhatsApp fields.", variant: "destructive" });
            return;
        }
        try {
            const response = await fetch(`/api/integrations/whatsapp/connect`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ userId: currentUser.id, ...whatsappAccount })
            });
            const data = await response.json();
            if (data.success) {
                toast({ title: commonT("success"), description: data.message, variant: "default" });
                // Re-fetch accounts to update UI
                setLoadingIntegrations(true);
                const whatsappResponse = await fetch(`/api/integrations/whatsapp?userId=${currentUser.id}`);
                const whatsappData = await whatsappResponse.json();
                if (whatsappData.success && whatsappData.accounts.length > 0) {
                    setWhatsappAccount(whatsappData.accounts[0]);
                }
                setLoadingIntegrations(false);
            } else {
                toast({ title: commonT("error"), description: data.error, variant: "destructive" });
            }
        } catch (error) {
            console.error("Error saving WhatsApp connection:", error);
            toast({ title: commonT("error"), description: "An error occurred during WhatsApp connection.", variant: "destructive" });
        }
    };

    // Handle WhatsApp Disconnection
    const handleDisconnectWhatsapp = async () => {
        if (!whatsappAccount || !whatsappAccount.id) return;
        try {
            const response = await fetch(`/api/integrations/whatsapp/disconnect/${whatsappAccount.id}`, {
                method: 'DELETE'
            });
            const data = await response.json();
            if (data.success) {
                toast({ title: commonT("success"), description: data.message, variant: "default" });
                setWhatsappAccount({ phoneNumberId: '', wabaId: '', accessToken: '', phoneNumber: '', name: '' });
            } else {
                toast({ title: commonT("error"), description: data.error, variant: "destructive" });
            }
        } catch (error) {
            console.error("Error disconnecting WhatsApp:", error);
            toast({ title: commonT("error"), description: "An error occurred during WhatsApp disconnection.", variant: "destructive" });
        }
    };


    return (
        <div className="min-h-screen bg-background p-6 relative overflow-hidden" dir={locale === "ar" ? "rtl" : "ltr"}>
            <FloatingDots />
            <div className="max-w-4xl mx-auto relative z-10">
                <PageShell
                    title={t("title")}
                    subtitle={t("subtitle")}
                    showBackButton
                    variant="gradient"
                >
                    <Tabs defaultValue="general" className="space-y-6">
                    <TabsList className="bg-slate-700/50 w-full justify-start">
                        <TabsTrigger value="general" className="flex items-center gap-2">
                            <User className="w-4 h-4" />
                            {t("general")}
                        </TabsTrigger>
                        <TabsTrigger value="notifications" className="flex items-center gap-2">
                            <Bell className="w-4 h-4" />
                            {t("notifications")}
                        </TabsTrigger>
                        <TabsTrigger value="privacy" className="flex items-center gap-2">
                            <Shield className="w-4 h-4" />
                            {t("privacy")}
                        </TabsTrigger>
                        <TabsTrigger value="security" className="flex items-center gap-2">
                            <Lock className="w-4 h-4" />
                            {t("security")}
                        </TabsTrigger>
                        <TabsTrigger value="billing" className="flex items-center gap-2">
                            <CreditCard className="w-4 h-4" />
                            {t("billing")}
                        </TabsTrigger>
                        <TabsTrigger value="integrations" className="flex items-center gap-2">
                            <Globe className="w-4 h-4" />
                            {t("integrations")}
                        </TabsTrigger>
                    </TabsList>

                    {/* General Settings */}
                    <TabsContent value="general">
                        <Card className="bg-slate-800/50 border-primary/20 backdrop-blur space-y-6">
                            <CardHeader>
                                <CardTitle>{t("generalSettings")}</CardTitle>
                                <CardDescription>{t("basicAccountInfo")}</CardDescription>
                            </CardHeader>
                            <CardContent className="space-y-6">
                                <div>
                                    <label className="text-sm font-medium text-gray-300 block mb-2">
                                        {t("emailAddress")}
                                    </label>
                                    <Input value={settings.email} disabled className="bg-slate-700/50 border-slate-600" />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-gray-300 block mb-2">
                                        {t("phoneNumber")}
                                    </label>
                                    <Input value={settings.phone} className="bg-slate-700/50 border-slate-600" onChange={(e) => setSettings({ ...settings, phone: e.target.value })} />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-gray-300 block mb-2">
                                        {t("language")}
                                    </label>
                                    <select
                                        value={settings.language}
                                        onChange={(e) => {
                                            setSettings({ ...settings, language: e.target.value });
                                            // Redirect to update locale
                                            router.push(pathname.replace(/^\/(ar|en)/, `/${e.target.value}`));
                                        }}
                                        className="w-full bg-slate-700/50 border border-slate-600 rounded-lg px-3 py-2 text-white"
                                    >
                                        <option value="en">English</option>
                                        <option value="ar">العربية</option>
                                    </select>
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-gray-300 block mb-2">
                                        {t("timezone")}
                                    </label>
                                    <select
                                        value={settings.timezone}
                                        onChange={(e) => setSettings({ ...settings, timezone: e.target.value })}
                                        className="w-full bg-slate-700/50 border border-slate-600 rounded-lg px-3 py-2 text-white"
                                    >
                                        <option value="GST">GST (UAE)</option>
                                        <option value="AST">AST</option>
                                        <option value="UTC">UTC</option>
                                    </select>
                                </div>
                                <Button className="bg-gradient-to-r from-primary to-primary/70 hover:from-primary/90 hover:to-primary/60 text-primary-foreground font-semibold">
                                    {t("saveChanges")}
                                </Button>
                            </CardContent>
                        </Card>
                    </TabsContent>

                    {/* Notifications */}
                    <TabsContent value="notifications">
                        <Card className="bg-slate-800/50 border-primary/20 backdrop-blur">
                            <CardHeader>
                                <CardTitle>{t("notificationSettings")}</CardTitle>
                                <CardDescription>{t("controlNotifications")}</CardDescription>
                            </CardHeader>
                            <CardContent className="space-y-4">
                                {[
                                    { key: "email", label: t("emailNotifications") },
                                    { key: "sms", label: t("smsNotifications") },
                                    { key: "push", label: t("pushNotifications") },
                                ].map((notif) => (
                                    <div key={notif.key} className="flex items-center justify-between p-4 bg-slate-700/30 rounded-lg border border-slate-600">
                                        <label className="text-white font-medium">{notif.label}</label>
                                        <input type="checkbox" defaultChecked={settings.notifications[notif.key as keyof typeof settings.notifications]} onChange={(e) => setSettings(prev => ({...prev, notifications: {...prev.notifications, [notif.key]: e.target.checked}}))} className="w-5 h-5 cursor-pointer" />
                                    </div>
                                ))}
                                <Button className="bg-gradient-to-r from-primary to-primary/70 hover:from-primary/90 hover:to-primary/60 text-primary-foreground font-semibold">
                                    {t("saveChanges")}
                                </Button>
                            </CardContent>
                        </Card>
                    </TabsContent>

                    {/* Privacy */}
                    <TabsContent value="privacy">
                        <Card className="bg-slate-800/50 border-primary/20 backdrop-blur">
                            <CardHeader>
                                <CardTitle>{t("privacySettings")}</CardTitle>
                                <CardDescription>{t("controlDataSharing")}</CardDescription>
                            </CardHeader>
                            <CardContent className="space-y-4">
                                <div className="p-4 bg-slate-700/30 rounded-lg border border-slate-600">
                                    <p className="text-white font-medium mb-3">{t("profileVisibility")}</p>
                                    <div className="space-y-2">
                                        {["public", "private", "team"].map((level) => (
                                            <label key={level} className="flex items-center gap-3 cursor-pointer">
                                                <input type="radio" name="profile" defaultChecked={level === settings.privacy.profile} onChange={() => setSettings(prev => ({...prev, privacy: {...prev.privacy, profile: level as "public" | "private" | "team"}}))} className="w-4 h-4" />
                                                <span className="text-gray-300">{t(level)}</span>
                                            </label>
                                        ))}
                                    </div>
                                </div>
                                <div className="flex items-center justify-between p-4 bg-slate-700/30 rounded-lg border border-slate-600">
                                    <label className="text-white font-medium">{t("usageAnalytics")}</label>
                                    <input type="checkbox" defaultChecked={settings.privacy.analytics} onChange={(e) => setSettings(prev => ({...prev, privacy: {...prev.privacy, analytics: e.target.checked}}))} className="w-5 h-5 cursor-pointer" />
                                </div>
                                <Button className="bg-gradient-to-r from-primary to-primary/70 hover:from-primary/90 hover:to-primary/60 text-primary-foreground font-semibold">
                                    {t("saveChanges")}
                                </Button>
                            </CardContent>
                        </Card>
                    </TabsContent>

                    {/* Security */}
                    <TabsContent value="security">
                        <Card className="bg-slate-800/50 border-primary/20 backdrop-blur">
                            <CardHeader>
                                <CardTitle>{t("securitySettings")}</CardTitle>
                                <CardDescription>{t("keepAccountSecure")}</CardDescription>
                            </CardHeader>
                            <CardContent className="space-y-4">
                                <Button variant="outline" className="w-full border-primary/20">
                                    {t("changePassword")}
                                </Button>
                                <Button variant="outline" className="w-full border-primary/20">
                                    {t("enableTwoFactorAuth")}
                                </Button>
                                <Button variant="outline" className="w-full border-primary/20">
                                    {t("manageDevices")}
                                </Button>
                                <div className="p-4 bg-green-500/10 border border-green-500/30 rounded-lg">
                                    <Badge className="bg-green-500/20 text-green-400 border-green-500/30 mb-2">
                                        ✓ {t("verified")}
                                    </Badge>
                                    <p className="text-gray-300 text-sm">{t("accountSecure")}</p>
                                </div>
                                <Button className="bg-gradient-to-r from-primary to-primary/70 hover:from-primary/90 hover:to-primary/60 text-primary-foreground font-semibold">
                                    {t("saveChanges")}
                                </Button>
                            </CardContent>
                        </Card>
                    </TabsContent>

                    {/* Billing */}
                    <TabsContent value="billing">
                        <Card className="bg-slate-800/50 border-primary/20 backdrop-blur">
                            <CardHeader>
                                <CardTitle>{t("billingSettings")}</CardTitle>
                                <CardDescription>{t("managePaymentSubscription")}</CardDescription>
                            </CardHeader>
                            <CardContent className="space-y-4">
                                <div className="p-4 bg-slate-700/30 rounded-lg border border-slate-600">
                                    <p className="text-gray-400 text-sm">{t("currentPlan")}</p>
                                    <p className="text-2xl font-bold text-white mt-2">
                                        {t("premiumPlan")}
                                    </p>
                                    <p className="text-gray-400 text-sm mt-1">{t("pricePerMonth", { amount: "350 درهم" })}</p>
                                </div>
                                <Button variant="outline" className="w-full border-primary/20">
                                    {t("updatePaymentMethod")}
                                </Button>
                                <Button variant="outline" className="w-full border-primary/20">
                                    {t("viewInvoices")}
                                </Button>
                                <Button className="bg-gradient-to-r from-primary to-primary/70 hover:from-primary/90 hover:to-primary/60 text-primary-foreground font-semibold">
                                    {t("saveChanges")}
                                </Button>
                            </CardContent>
                        </Card>
                    </TabsContent>

                    {/* Integrations Tab */}
                    <TabsContent value="integrations">
                        <Card className="bg-slate-800/50 border-primary/20 backdrop-blur">
                            <CardHeader>
                                <CardTitle>{t("integrations")}</CardTitle>
                                <CardDescription>{t("manageIntegrations")}</CardDescription>
                            </CardHeader>
                            <CardContent className="space-y-6">
                                {loadingIntegrations ? (
                                    <div className="text-center text-gray-400 py-8">{commonT("loading")}</div>
                                ) : (
                                    <>
                                        {/* Instagram Integration */}
                                        <div className="space-y-4 p-4 border border-border/50 rounded-lg bg-slate-700/30">
                                            <div className="flex items-center gap-3">
                                                <Instagram className="w-6 h-6 text-primary" />
                                                <h3 className="text-xl font-semibold text-white">{t("instagramIntegration")}</h3>
                                            </div>
                                            {instagramAccount ? (
                                                <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center p-4 bg-slate-600/50 rounded-lg border border-primary/20">
                                                    <div>
                                                        <p className="text-white font-medium">@{instagramAccount.username}</p>
                                                        <p className="text-gray-400 text-sm">{t("connectionStatus")} <Badge className="bg-green-500/20 text-green-400 border-green-500/30">{t("connected")}</Badge></p>
                                                    </div>
                                                    <Button variant="destructive" onClick={handleDisconnectInstagram} className="mt-4 sm:mt-0">
                                                        {t("disconnectInstagram")}
                                                    </Button>
                                                </div>
                                            ) : (
                                                <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center p-4 bg-slate-600/50 rounded-lg border border-red-500/20">
                                                    <p className="text-red-400 text-sm">{t("instagramDisconnected")}</p>
                                                    <Button onClick={handleConnectInstagram} className="bg-primary hover:bg-primary/90 text-primary-foreground mt-4 sm:mt-0">
                                                        {t("connectInstagram")}
                                                    </Button>
                                                </div>
                                            )}
                                        </div>

                                        {/* WhatsApp Integration */}
                                        <div className="space-y-4 p-4 border border-border/50 rounded-lg bg-slate-700/30">
                                            <div className="flex items-center gap-3">
                                                <MessageCircle className="w-6 h-6 text-green-400" />
                                                <h3 className="text-xl font-semibold text-white">{t("whatsappIntegration")}</h3>
                                            </div>
                                            {whatsappAccount && whatsappAccount.id ? (
                                                <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center p-4 bg-slate-600/50 rounded-lg border border-primary/20">
                                                    <div>
                                                        <p className="text-white font-medium">{whatsappAccount.phoneNumber} ({whatsappAccount.name || 'N/A'})</p>
                                                        <p className="text-gray-400 text-sm">{t("connectionStatus")} <Badge className="bg-green-500/20 text-green-400 border-green-500/30">{t("connected")}</Badge></p>
                                                    </div>
                                                    <Button variant="destructive" onClick={handleDisconnectWhatsapp} className="mt-4 sm:mt-0">
                                                        {t("disconnectWhatsapp")}
                                                    </Button>
                                                </div>
                                            ) : (
                                                <>
                                                    <p className="text-gray-400 text-sm">{t("whatsappConnectInstructions")}</p>
                                                    <div className="space-y-4">
                                                        <div>
                                                            <label className="text-sm font-medium text-gray-300 block mb-2">{t("phoneNumberId")}</label>
                                                            <Input value={whatsappAccount.phoneNumberId} onChange={(e) => setWhatsappAccount({...whatsappAccount, phoneNumberId: e.target.value})} className="bg-slate-700/50 border-slate-600 text-white" />
                                                        </div>
                                                        <div>
                                                            <label className="text-sm font-medium text-gray-300 block mb-2">{t("wabaId")}</label>
                                                            <Input value={whatsappAccount.wabaId} onChange={(e) => setWhatsappAccount({...whatsappAccount, wabaId: e.target.value})} className="bg-slate-700/50 border-slate-600 text-white" />
                                                        </div>
                                                        <div>
                                                            <label className="text-sm font-medium text-gray-300 block mb-2">{t("whatsappNumber")}</label>
                                                            <Input value={whatsappAccount.phoneNumber} onChange={(e) => setWhatsappAccount({...whatsappAccount, phoneNumber: e.target.value})} placeholder="+9715XXXXXXX" className="bg-slate-700/50 border-slate-600 text-white" />
                                                        </div>
                                                        <div>
                                                            <label className="text-sm font-medium text-gray-300 block mb-2">{t("whatsappDisplayName")}</label>
                                                            <Input value={whatsappAccount.name || ''} onChange={(e) => setWhatsappAccount({...whatsappAccount, name: e.target.value})} className="bg-slate-700/50 border-slate-600 text-white" />
                                                        </div>
                                                        <div>
                                                            <label className="text-sm font-medium text-gray-300 block mb-2">{t("whatsappAccessToken")}</label>
                                                            <Input type="password" value={whatsappAccount.accessToken} onChange={(e) => setWhatsappAccount({...whatsappAccount, accessToken: e.target.value})} className="bg-slate-700/50 border-slate-600 text-white" />
                                                        </div>
                                                        <Button onClick={handleSaveWhatsappConnection} className="bg-primary hover:bg-primary/90 text-primary-foreground">
                                                            {t("saveWhatsappConnection")}
                                                        </Button>
                                                    </div>
                                                </>
                                            )}
                                        </div>
                                    </>
                                )}
                            </CardContent>
                        </Card>
                    </TabsContent>
                    </Tabs>
                </PageShell>
            </div>
        </div>
    );
}
```

---

### 5. الذكاء الاصطناعي والتأثير التسويقي (AI & Marketing Impact)

بعد دمج Instagram و WhatsApp، تفتح Imperium Gate آفاقاً جديدة للذكاء الاصطناعي والتسويق:

1.  **منشئ الإعلانات بالذكاء الاصطناعي (AI Ad Creator)**:
    *   **نشر مباشر**: يمكن للـ AI الآن نشر الإعلانات التي تم إنشاؤها مباشرة على Instagram باستخدام الـ `accessToken` المخزن.
    *   **تحسين المحتوى**: AI يحلل أداء الإعلانات السابقة ويقترح تعديلات على النصوص أو المرئيات قبل النشر لزيادة الفعالية.
    *   **اختبار A/B آلي**: AI ينشئ عدة نسخ من الإعلان ويقوم بإجراء اختبار A/B تلقائياً لتحسين النتائج.

2.  **إدارة علاقات العملاء الذكية (AI-Powered CRM)**:
    *   **التعامل مع رسائل Instagram DM و WhatsApp**: AI يقوم بالرد التلقائي على الاستفسارات المتكررة، ويصنف الرسائل، ويوجه الرسائل المعقدة للمسوق البشري.
    *   **تتبع التفاعلات**: جميع الرسائل من Instagram و WhatsApp تُسجل في ملف العميل في CRM.
    *   **تقييم العملاء المحتملين**: AI يحلل التفاعلات في الدردشات لتقييم مدى اهتمام العميل ونقاطه.

3.  **مركز الاتصال الصوتي والرسائل الذكي (AI Voice & Messaging Center)**:
    *   **ردود WhatsApp التلقائية**: AI يرسل قوالب رسائل WhatsApp المعتمدة من Meta بناءً على الأحداث (مثال: تأكيد موعد، تذكير بعرض).
    *   **توجيه المحادثات**: AI يوجه العملاء خلال محادثات WhatsApp للإجابة على الأسئلة الشائعة أو جمع المعلومات.
    *   **تحليل المحادثات**: AI يحلل محتوى الدردشات لتحديد المشاعر والفرص.

4.  **التحليلات والرؤى الذكية (AI Analytics & Insights)**:
    *   **بيانات أداء حقيقية**: سحب بيانات أداء الإعلانات من Meta Graph API مباشرة لتقديم تحليلات دقيقة بدلاً من البيانات الوهمية.
    *   **تحديد الاتجاهات**: AI يكتشف الاتجاهات في تفاعلات العملاء عبر Instagram و WhatsApp ويقدم رؤى حول اهتماماتهم.

---

### 6. الأمان (Security)

نقاط أمان حرجة يجب مراعاتها:

*   **تشفير الـ Access Tokens**: **هذا أهم شيء**. يجب تشفير `accessToken` لكل من `InstagramAccount` و `WhatsAppAccount` في قاعدة البيانات باستخدام المفتاح `ACCESS_TOKEN_ENCRYPTION_KEY` ولا يتم فك تشفيرها إلا عند الحاجة الفعلية لإجراء استدعاء لـ API.
*   **حدود الأذونات (Least Privilege)**: اطلب فقط الأذونات الضرورية من المستخدمين أثناء عملية Meta OAuth.
*   **التحقق من Webhook Signature**: دائماً تحقق من توقيع الـ Webhook الوارد من Meta للتأكد من أنه قادم من Meta وليس من مصدر مزيف.
*   **الوصول إلى الـ APIs**: استخدم `supabaseAdmin` أو أي وسيلة مصادقة قوية لضمان أن الـ API routes الخاصة بدمج الحسابات يمكن الوصول إليها فقط من قبل المستخدمين المصرح لهم.
*   **إدارة الـ Tokens**: يجب أن تكون هناك آلية لتحديث الـ Access Tokens إذا انتهت صلاحيتها (رغم أن الـ Long-Lived Tokens لـ Meta عادة لا تنتهي صلاحيتها ما لم يغير المستخدم كلمة المرور أو يلغي الربط).

---

بهذه الخطة، ستتمكن Imperium Gate من الانتقال من مجرد واجهة عرض جميلة إلى منصة تسويقية عاملة وفعالة، مع قدرات AI حقيقية تستفيد من الاتصال المباشر بحسابات المستخدمين على Instagram و WhatsApp. هذا هو جوهر بناء إمبراطورية التسويق الرقمي!


هذه هي المفاتيح الأساسية التي سيتطلبها تطبيقك للتحدث مع Meta (Facebook/Instagram).

1.  **META_APP_ID**: معرّف تطبيقك على Meta.
2.  **META_APP_SECRET**: المفتاح السري لتطبيقك على Meta. **لا تشاركه أبداً**.
3.  **NEXT_PUBLIC_META_REDIRECT_URI**: رابط إعادة التوجيه الذي سيستخدمه Meta بعد مصادقة المستخدم. **يجب أن يكون رابطاً عاماً وقابلاً للوصول إليه من الإنترنت.**

**أضف هذه المتغيرات إلى ملف `.env.local` الخاص بك:**

```env
# Meta (Facebook/Instagram) Integration
META_APP_ID=YOUR_META_APP_ID_HERE # يجب الحصول عليه من Meta Developer Dashboard
META_APP_SECRET=YOUR_META_APP_SECRET_HERE # يجب الحصول عليه من Meta Developer Dashboard (مفتاح حساس جداً)
NEXT_PUBLIC_META_REDIRECT_URI=http://localhost:8080/api/integrations/instagram/callback # مهم جداً: هذا يجب أن يكون رابطاً قابلاً للوصول إليه
# For production, it would be: https://your-domain.com/api/integrations/instagram/callback

META_API_VERSION=v19.0 # أو أحدث إصدار متاح، تحقق من وثائق Meta

# مفتاح التشفير للرموز المميزة (ضروري للأمان)
ACCESS_TOKEN_ENCRYPTION_KEY=YOUR_STRONG_ENCRYPTION_KEY_32_CHARS # يجب أن يكون 32 بايت (256 بت)
```

**كيف تحصل على `META_APP_ID` و `META_APP_SECRET`:**
1.  اذهب إلى [Meta for Developers](https://developers.facebook.com/).
2.  قم بتسجيل الدخول وإنشاء تطبيق جديد (App).
3.  اختر نوع التطبيق (غالباً "Business" أو "None").
4.  بعد إنشاء التطبيق، اذهب إلى "Settings" -> "Basic". ستجد `App ID` و `App Secret` هناك.
5.  في نفس المكان (Basic Settings)، أضف `NEXT_PUBLIC_META_REDIRECT_URI` إلى قائمة "Valid OAuth Redirect URIs". **هذه خطوة حاسمة جداً**.

### الخطوة 2: تحديث قاعدة البيانات (Prisma Schema)

لقد قمنا بالفعل بتوفير تحديثات Schema في الرد السابق. تأكد من أن ملف `prisma/schema.prisma` الخاص بك يحتوي على نموذج `InstagramAccount` وربطه بنموذج `User` الخاص بك:

```prisma
// FILE: prisma/schema.prisma
// ... existing models

model User { // Make sure this model exists or use your Profile model
  id                 String    @id @default(uuid())
  email              String    @unique
  name               String?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  instagramAccounts InstagramAccount[]
  // ... other relations
}

model InstagramAccount {
  id                    String    @id @default(uuid())
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  igUserId              String    @unique // Instagram Business Account ID from Meta
  fbPageId              String    @unique // Connected Facebook Page ID
  
  name                  String
  username              String    @unique
  profilePictureUrl     String?
  
  accessToken           String // Encrypted long-lived access token
  expiresAt             DateTime? 
  
  status                String    @default("connected")
  lastSyncedAt          DateTime?
  
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  instagramDMs          InstagramDM[]
  instagramPosts        InstagramPost[]
}

model InstagramDM {
  id                    String    @id @default(uuid())
  instagramAccountId    String
  instagramAccount      InstagramAccount @relation(fields: [instagramAccountId], references: [id], onDelete: Cascade)

  senderId              String
  recipientId           String
  message               String
  isRead                Boolean   @default(false)
  sentAt                DateTime  @default(now())
  
  leadId                String?
  lead                  Lead?     @relation(fields: [leadId], references: [id])
}

// ... rest of your models (Lead, InstagramCampaign, InstagramAd, AdAsset, AdPerformance, WhatsAppAccount, WhatsAppMessage)
```

**بعد أي تغيير في `schema.prisma`، لا تنسى تشغيل:**
`npx prisma migrate dev --name <your_migration_name>`
`npx prisma generate`

### الخطوة 3: إضافة دوال التشفير/فك التشفير (`lib/encryption.ts`)

قم بإنشاء هذا الملف لتأمين الـ Access Tokens.

```typescript
// FILE: app2/lib/encryption.ts
import crypto from 'crypto';

const algorithm = 'aes-256-cbc';
const IV_LENGTH = 16; // For AES, this is always 16 bytes

// IMPORTANT: ENCRYPTION_KEY must be exactly 32 bytes (256 bits) for AES-256-CBC
// Use a strong, random key in production. e.g., crypto.randomBytes(32).toString('hex')
if (!process.env.ACCESS_TOKEN_ENCRYPTION_KEY || process.env.ACCESS_TOKEN_ENCRYPTION_KEY.length !== 32) {
  console.error("ACCESS_TOKEN_ENCRYPTION_KEY is not 32 bytes or not set. Encryption will not work securely.");
  // In production, you might want to crash or handle this more strictly.
}
const ENCRYPTION_KEY = Buffer.from(process.env.ACCESS_TOKEN_ENCRYPTION_KEY || 'a_default_key_for_dev_only_1234567890', 'utf8'); // Fallback for dev, but highly insecure for prod.

export function encrypt(text: string): string {
  if (ENCRYPTION_KEY.length !== 32) {
    throw new Error('Encryption key must be 32 bytes for AES-256-CBC.');
  }
  
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv(algorithm, ENCRYPTION_KEY, iv);
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return iv.toString('hex') + ':' + encrypted;
}

export function decrypt(text: string): string {
  if (ENCRYPTION_KEY.length !== 32) {
    throw new Error('Encryption key must be 32 bytes for AES-256-CBC.');
  }

  const textParts = text.split(':');
  if (textParts.length !== 2) {
    throw new Error('Invalid encrypted text format. Expected IV:EncryptedText');
  }

  const iv = Buffer.from(textParts[0], 'hex');
  const encryptedText = Buffer.from(textParts[1], 'hex');
  const decipher = crypto.createDecipheriv(algorithm, ENCRYPTION_KEY, iv);
  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}
```

### الخطوة 4: واجهات برمجة التطبيقات (API Routes) للربط

هذه هي الـ API routes التي ستتعامل مع عملية Meta OAuth، جلب بيانات Instagram، وحفظها في قاعدة بياناتك.

#### أ. API لبدء الاتصال (`app/api/integrations/instagram/connect/route.ts`)

```typescript
// FILE: app2/app/api/integrations/instagram/connect/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase'; // To get the current user ID securely

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const userId = searchParams.get('userId'); // This should come from the authenticated session

  if (!userId) {
    // If no userId is explicitly passed (e.g., in a development scenario),
    // try to get it from the session if possible. In a real app, the frontend
    // should already know the userId of the authenticated user.
    const supabase = createAdminClient(); // Or use a regular authenticated supabase instance
    const { data: { session } } = await supabase.auth.getSession();
    if (session) {
      // If we can get it from session, use that.
      userId = session.user.id;
    } else {
      return NextResponse.json({ error: 'User ID is required for Instagram connection' }, { status: 401 });
    }
  }

  const metaAppId = process.env.META_APP_ID;
  const nextPublicMetaRedirectUri = process.env.NEXT_PUBLIC_META_REDIRECT_URI;
  const metaApiVersion = process.env.META_API_VERSION || 'v19.0';

  if (!metaAppId || !nextPublicMetaRedirectUri) {
    console.error('Missing Meta App ID or Redirect URI environment variables.');
    return NextResponse.json({ error: 'Server configuration error: Meta App ID or Redirect URI missing.' }, { status: 500 });
  }

  // Define the required permissions (scopes)
  // instagram_basic: to get user profile and insights
  // instagram_manage_comments: to reply to comments
  // instagram_manage_insights: to get media insights
  // instagram_content_publish: to publish media
  // instagram_manage_messages: to manage DMs
  // pages_show_list: to get list of Facebook Pages managed by user
  // pages_read_engagement: required to get connected IG Business Account
  // business_management: to manage Meta Business Assets
  const scope = [
    'instagram_basic',
    'instagram_manage_comments',
    'instagram_manage_insights',
    'instagram_content_publish',
    'instagram_manage_messages',
    'pages_show_list',
    'pages_read_engagement', // Required to access instagram_business_account field on a Page
    'business_management',
  ].join(',');

  const dialogUrl = `https://www.facebook.com/${metaApiVersion}/dialog/oauth?` +
    `client_id=${metaAppId}&` +
    `redirect_uri=${nextPublicMetaRedirectUri}&` +
    `scope=${scope}&` +
    `state=${userId}`; // Pass userId through 'state' to link back after OAuth

  return NextResponse.json({ redirectUrl: dialogUrl });
}
```

#### ب. API لمعالجة رد Meta OAuth (`app/api/integrations/instagram/callback/route.ts`)

هذا الـ API هو الذي سيتلقى الرد من Meta، ويقوم بخطوات المصادقة المعقدة للحصول على الـ Long-Lived Token وبيانات حساب Instagram.

```typescript
// FILE: app2/app/api/integrations/instagram/callback/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db'; // تأكد من استيراد prisma
import { encrypt } from '@/lib/encryption'; // تأكد من استيراد دالة التشفير

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const code = searchParams.get('code');
  const state = searchParams.get('state'); // هذا هو userId الذي أرسلناه
  const error = searchParams.get('error');

  // Handle OAuth errors from Meta
  if (error) {
    const errorDescription = searchParams.get('error_description') || 'Unknown error';
    console.error('Meta OAuth Error:', error, errorDescription);
    // Redirect to a user-friendly error page or the settings page with an error message
    return NextResponse.redirect(new URL(`/settings?tab=integrations&error=${encodeURIComponent(`Meta OAuth failed: ${errorDescription}`)}`, req.url));
  }

  // Ensure 'code' and 'state' are present
  if (!code || !state) {
    return NextResponse.redirect(new URL(`/settings?tab=integrations&error=${encodeURIComponent('Missing OAuth code or state parameter.')}`, req.url));
  }

  const userId = state; // The user who initiated the connection
  const metaAppId = process.env.META_APP_ID;
  const metaAppSecret = process.env.META_APP_SECRET;
  const nextPublicMetaRedirectUri = process.env.NEXT_PUBLIC_META_REDIRECT_URI;
  const metaApiVersion = process.env.META_API_VERSION || 'v19.0';

  // Basic server-side configuration check
  if (!metaAppId || !metaAppSecret || !nextPublicMetaRedirectUri) {
    console.error('Server configuration error: Missing Meta App ID, App Secret, or Redirect URI.');
    return NextResponse.redirect(new URL(`/settings?tab=integrations&error=${encodeURIComponent('Server configuration incomplete for Meta integration.')}`, req.url));
  }

  try {
    // 1. Exchange the 'code' for a short-lived user access token
    const tokenExchangeUrl = `https://graph.facebook.com/${metaApiVersion}/oauth/access_token?` +
                             `client_id=${metaAppId}&` +
                             `client_secret=${metaAppSecret}&` +
                             `code=${code}&` +
                             `redirect_uri=${nextPublicMetaRedirectUri}`;
    const tokenResponse = await fetch(tokenExchangeUrl, { method: 'GET' });
    const tokenData = await tokenResponse.json();

    if (tokenData.error) {
      console.error('Failed to get short-lived token:', tokenData.error);
      return NextResponse.redirect(new URL(`/settings?tab=integrations&error=${encodeURIComponent(`Failed to get short-lived Meta token: ${tokenData.error.message}`)}`, req.url));
    }
    const shortLivedAccessToken = tokenData.access_token;

    // 2. Exchange the short-lived token for a long-lived user access token
    const longLivedTokenExchangeUrl = `https://graph.facebook.com/${metaApiVersion}/oauth/access_token?` +
                                      `grant_type=fb_exchange_token&` +
                                      `client_id=${metaAppId}&` +
                                      `client_secret=${metaAppSecret}&` +
                                      `fb_exchange_token=${shortLivedAccessToken}`;
    const longLivedTokenResponse = await fetch(longLivedTokenExchangeUrl, { method: 'GET' });
    const longLivedTokenData = await longLivedTokenResponse.json();

    if (longLivedTokenData.error) {
      console.error('Failed to get long-lived token:', longLivedTokenData.error);
      return NextResponse.redirect(new URL(`/settings?tab=integrations&error=${encodeURIComponent(`Failed to get long-lived Meta token: ${longLivedTokenData.error.message}`)}`, req.url));
    }
    const longLivedAccessToken = longLivedTokenData.access_token;
    // const tokenExpiresAt = new Date(Date.now() + (longLivedTokenData.expires_in * 1000)); // expires_in is usually absent for long-lived tokens unless explicit.

    // 3. Get Facebook Pages managed by the user
    // We need 'pages_show_list' permission for this
    const pagesUrl = `https://graph.facebook.com/${metaApiVersion}/me/accounts?access_token=${longLivedAccessToken}`;
    const pagesResponse = await fetch(pagesUrl, { method: 'GET' });
    const pagesData = await pagesResponse.json();

    if (pagesData.error) {
        console.error('Failed to get Facebook Pages:', pagesData.error);
        return NextResponse.redirect(new URL(`/settings?tab=integrations&error=${encodeURIComponent(`Failed to retrieve Facebook Pages: ${pagesData.error.message}`)}`, req.url));
    }

    let connectedIgAccountDetails: any = null;

    // Iterate through pages to find one connected to an Instagram Business Account
    for (const page of pagesData.data) {
        // Need 'pages_read_engagement' to access instagram_business_account field
        const pageDetailsUrl = `https://graph.facebook.com/${metaApiVersion}/${page.id}?fields=instagram_business_account&access_token=${longLivedAccessToken}`;
        const pageDetailsResponse = await fetch(pageDetailsUrl, { method: 'GET' });
        const pageDetailsData = await pageDetailsResponse.json();

        if (pageDetailsData.instagram_business_account) {
            // Found a Facebook Page connected to an Instagram Business Account
            const igBusinessAccountId = pageDetailsData.instagram_business_account.id;

            // Get Instagram Business Account details
            const igAccountDetailsUrl = `https://graph.facebook.com/${metaApiVersion}/${igBusinessAccountId}?fields=id,username,name,profile_picture_url&access_token=${longLivedAccessToken}`;
            const igAccountDetailsResponse = await fetch(igAccountDetailsUrl, { method: 'GET' });
            const igAccountDetailsData = await igAccountDetailsResponse.json();

            connectedIgAccountDetails = {
                igUserId: igAccountDetailsData.id,
                fbPageId: page.id, // Store the connected Facebook Page ID
                name: igAccountDetailsData.name,
                username: igAccountDetailsData.username,
                profilePictureUrl: igAccountDetailsData.profile_picture_url,
            };
            break; // Assuming one Instagram Business Account per user for simplicity
        }
    }

    if (!connectedIgAccountDetails) {
        return NextResponse.redirect(new URL(`/settings?tab=integrations&error=${encodeURIComponent('No Instagram Business Account found linked to your Facebook Pages. Please ensure your Instagram is a Business Account and linked to a Facebook Page.')}`, req.url));
    }

    // 4. Encrypt the long-lived access token and save Instagram account details to Prisma
    const encryptedAccessToken = encrypt(longLivedAccessToken);

    await prisma.instagramAccount.upsert({
      where: { igUserId: connectedIgAccountDetails.igUserId }, // Use igUserId as unique identifier
      update: {
        accessToken: encryptedAccessToken,
        fbPageId: connectedIgAccountDetails.fbPageId,
        name: connectedIgAccountDetails.name,
        username: connectedIgAccountDetails.username,
        profilePictureUrl: connectedIgAccountDetails.profilePictureUrl,
        userId: userId, // Ensure linking to the correct user
        status: 'connected',
        expiresAt: null, // Long-lived tokens usually don't expire for system users, or managed by Meta
      },
      create: {
        igUserId: connectedIgAccountDetails.igUserId,
        fbPageId: connectedIgAccountDetails.fbPageId,
        name: connectedIgAccountDetails.name,
        username: connectedIgAccountDetails.username,
        profilePictureUrl: connectedIgAccountDetails.profilePictureUrl,
        accessToken: encryptedAccessToken,
        userId: userId,
        status: 'connected',
        expiresAt: null,
      },
    });

    // Redirect user to the settings page with a success message
    return NextResponse.redirect(new URL(`/settings?tab=integrations&success=${encodeURIComponent('Instagram Business Account connected successfully!')}`, req.url));

  } catch (err: any) {
    console.error('Instagram Integration Callback Error:', err);
    return NextResponse.redirect(new URL(`/settings?tab=integrations&error=${encodeURIComponent(`Internal server error during Instagram connection: ${err.message}`)}`, req.url));
  }
}
```

#### ج. API لجلب حسابات Instagram للمستخدم (`app/api/integrations/instagram/route.ts`)

هذا الـ API سيجلب حسابات Instagram المرتبطة بالمستخدم الحالي لعرضها في واجهة المستخدم.

```typescript
// FILE: app2/app/api/integrations/instagram/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { createAdminClient } from '@/lib/supabase'; // To verify user session

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  let userId = searchParams.get('userId');

  // Ensure user is authenticated
  const supabase = createAdminClient(); // Using admin client, but could be a regular authenticated client
  const { data: { session } } = await supabase.auth.getSession();

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Prioritize userId from session for security
  userId = session.user.id;

  try {
    const instagramAccounts = await prisma.instagramAccount.findMany({
      where: { userId: userId },
      select: {
        id: true,
        username: true,
        name: true,
        profilePictureUrl: true,
        status: true,
        lastSyncedAt: true,
      },
    });

    return NextResponse.json({ success: true, accounts: instagramAccounts });
  } catch (error: any) {
    console.error('Failed to fetch Instagram accounts:', error);
    return NextResponse.json({ error: 'Failed to fetch Instagram accounts' }, { status: 500 });
  }
}
```

#### د. API لقطع اتصال Instagram (`app/api/integrations/instagram/disconnect/[id]/route.ts`)

```typescript
// FILE: app2/app/api/integrations/instagram/disconnect/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { createAdminClient } from '@/lib/supabase'; // To verify user session

export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } } // This 'id' is the InstagramAccount.id from your DB
) {
  const { id: instagramAccountId } = params;

  // Ensure user is authenticated
  const supabase = createAdminClient();
  const { data: { session } } = await supabase.auth.getSession();

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    // Verify that the Instagram account belongs to the current user
    const existingAccount = await prisma.instagramAccount.findUnique({
      where: { id: instagramAccountId },
      select: { userId: true, igUserId: true, fbPageId: true, accessToken: true },
    });

    if (!existingAccount || existingAccount.userId !== session.user.id) {
      return NextResponse.json({ error: 'Unauthorized: Account does not belong to user.' }, { status: 403 });
    }

    // Optional: Revoke token on Meta's side (more robust)
    // You would use the accessToken to call Meta's API to revoke permissions.
    // Example:
    // const metaAppId = process.env.META_APP_ID;
    // const decryptedAccessToken = decrypt(existingAccount.accessToken);
    // await fetch(`https://graph.facebook.com/${metaAppId}/permissions?access_token=${decryptedAccessToken}`, { method: 'DELETE' });

    await prisma.instagramAccount.delete({
      where: { id: instagramAccountId },
    });

    return NextResponse.json({ success: true, message: 'Instagram account disconnected successfully.' });
  } catch (error: any) {
    console.error('Failed to disconnect Instagram account:', error);
    return NextResponse.json({ error: `Failed to disconnect Instagram account: ${error.message}` }, { status: 500 });
  }
}
```

### الخطوة 5: تحديث واجهة المستخدم (Frontend UI) في `app/[locale]/settings/page.tsx`

هذا هو الملف الذي قمنا بتعديله في الرد السابق لإضافة تبويب "Integrations". الكود الذي قدمته في الرد السابق لـ `settings/page.tsx` هو صحيح ومناسب للتعامل مع هذه الـ APIs.

**ملاحظات إضافية على واجهة المستخدم:**
*   بعد ربط Instagram بنجاح، سيتم عرض اسم المستخدم وصورة الملف الشخصي للحساب المربوط.
*   تستخدم `useSearchParams` للتحقق من رسائل النجاح/الخطأ التي تأتي بعد إعادة التوجيه من Meta.

---

### مراجعة سريعة لتدفق Instagram OAuth:

1.  **المستخدم يضغط "Connect Instagram"**:
    *   الـ Frontend يستدعي `GET /api/integrations/instagram/connect`.
    *   هذا الـ API يجهز رابط Meta OAuth (مع `client_id`, `redirect_uri`, `scope`, `state=userId`) ويعيده.
    *   الـ Frontend يعيد توجيه المستخدم إلى رابط Meta OAuth.
2.  **المستخدم يصادق في Meta**:
    *   يوافق المستخدم على الأذونات المطلوبة في نافذة Meta.
    *   Meta يعيد توجيه المستخدم إلى `NEXT_PUBLIC_META_REDIRECT_URI` الخاص بك (`/api/integrations/instagram/callback`) مع `code` و `state`.
3.  **الـ Backend يتلقى الرد (`/api/integrations/instagram/callback`)**:
    *   يستخدم `code` و `client_id` و `client_secret` للحصول على short-lived `access_token` من Meta.
    *   يستخدم short-lived `access_token` للحصول على long-lived `access_token` من Meta.
    *   يستخدم long-lived `access_token` للحصول على قائمة صفحات Facebook التي يديرها المستخدم.
    *   يتفحص كل صفحة للعثور على صفحة مرتبطة بـ **Instagram Business Account**.
    *   يجلب تفاصيل Instagram Business Account (مثل `username`, `profile_picture_url`).
    *   **يشفر** long-lived `access_token` ويحفظ جميع التفاصيل (IG ID, FB Page ID, Username, Encrypted Token) في قاعدة بياناتك (Prisma `InstagramAccount` model) ويربطها بـ `userId`.
    *   يعيد توجيه المستخدم إلى صفحة الإعدادات (`/settings?tab=integrations`) مع رسالة نجاح.
4.  **الـ Frontend يعرض الحالة**:
    *   صفحة الإعدادات تجلب الحسابات المرتبطة من `GET /api/integrations/instagram` وتعرضها.

---

بهذه الخطوات والأكواد، ستكون قد وضعت أساساً متيناً لربط Instagram بمنصة Imperium Gate، مما يفتح الباب واسعاً لقدرات تسويقية متقدمة بالذكاء الاصطناعي!

اسأل عن أي شيء يتعلق بالبرمجة...



 Facebook (Meta)، Instagram، و WhatsApp فيما يتعلق بالمفاتيح والأذونات هو مفتاح الدمج الصحيح.

الإجابة المختصرة: **لا، ليسوا نفس المفاتيح تماماً، ولكنهم مترابطون بشكل وثيق من خلال نظام Meta Ecosystem.**

دعنا نوضح العلاقة والمتطلبات لكل منصة:

---

## العلاقة بين Meta (Facebook)، Instagram، و WhatsApp ومتطلبات المفاتيح

جميع هذه المنصات (Facebook، Instagram، WhatsApp) تملكها شركة **Meta**. للوصول إلى واجهات برمجتها (APIs)، يتم ذلك عادة من خلال **Meta for Developers** (المعروف سابقاً بـ Facebook for Developers).

**الفكرة الأساسية:**
*   لديك **Meta App** (تطبيق Meta/Facebook) واحد في Meta for Developers. هذا التطبيق هو نقطة الدخول لجميع تكاملاتك.
*   هذا الـ Meta App لديه **App ID** و **App Secret** خاصين به. هذه المفاتيح هي **نفسها** التي ستستخدمها للبدء في ربط Instagram ولإعداد تكامل WhatsApp (ولكن ليست الـ Access Token الخاصة بـ WhatsApp).
*   داخل هذا الـ Meta App، يمكنك إضافة منتجات (Products) مثل "Instagram Basic Display"، "WhatsApp Business Platform"، "Facebook Login"، "Marketing API"، إلخ.
*   كل منتج من هذه المنتجات (Instagram API، WhatsApp API) له متطلبات أذونات (Permissions) ورموز وصول (Access Tokens) خاصة به.

### تفصيل المفاتيح لكل منصة:

#### 1. Meta App (Facebook App) - الأساس المشترك

*   **`META_APP_ID`**
*   **`META_APP_SECRET`**

**هذه المفاتيح هي المفاتيح الأساسية لتطبيقك في Meta for Developers. ستستخدمها لـ:**
*   **Instagram Integration:** لبدء تدفق OAuth والحصول على `User Access Token`.
*   **WhatsApp Integration:** لإنشاء `System User Access Token` وتكوين الـ Webhooks.
*   **أي تكاملات Facebook أخرى:** مثل إدارة الصفحات أو الإعلانات على Facebook.

**الخلاصة:** `META_APP_ID` و `META_APP_SECRET` هما مفتاحان **مشتركان وضروريان** للبدء في أي تكامل مع Meta.

---

#### 2. Instagram Business Account Integration

*   **`META_APP_ID`** و **`META_APP_SECRET`**: (مشتركان) تستخدمهما لبدء عملية OAuth.
*   **`NEXT_PUBLIC_META_REDIRECT_URI`**: (مشترك، ولكن قد تحتاج مساراً محدداً لـ Instagram) رابط إعادة التوجيه لإنهاء عملية OAuth.
*   **`User Access Token` (Long-Lived)**:
    *   **خاص بـ Instagram:** يتم الحصول عليه من خلال عملية OAuth للمستخدم. هذا الرمز يمنح تطبيقك إمكانية الوصول إلى بيانات Instagram (مثل الـ DMs، والـ Insights) نيابة عن المستخدم الذي قام بالربط.
    *   هذا الرمز **لا يستخدم** للوصول إلى WhatsApp.
*   **`Instagram Business Account ID`**: (خاص بـ Instagram) معرّف حساب Instagram التجاري الفعلي.
*   **`Facebook Page ID`**: (خاص بـ Instagram، لكنه معرّف لصفحة فيسبوك) معرّف صفحة فيسبوك المرتبطة بحساب Instagram التجاري.

**الخلاصة لـ Instagram:** تبدأ بمفاتيح Meta App المشتركة، لكنك تحصل على `User Access Token` و `IDs` **خاصة بـ Instagram** والتي تُستخدم حصرياً للوصول إلى Instagram.

---

#### 3. WhatsApp Business Platform Integration

*   **`META_APP_ID`** و **`META_APP_SECRET`**: (مشتركان) تستخدمهما عند إعداد WhatsApp Business Platform في Meta Business Manager، ولربط تطبيق Meta الخاص بك بـ WABA الخاص بك.
*   **`WABA ID` (WhatsApp Business Account ID)**: (خاص بـ WhatsApp) معرّف حساب واتساب التجاري الخاص بك.
*   **`Phone Number ID`**: (خاص بـ WhatsApp) معرّف رقم الهاتف الذي ستستخدمه لتلقي وإرسال الرسائل.
*   **`System User Access Token`**:
    *   **خاص بـ WhatsApp:** يتم إنشاؤه في Meta Business Manager ويرتبط بمستخدم نظام (System User) بدلاً من مستخدم بشري. يمنح هذا الرمز تطبيقك إذن الوصول إلى WhatsApp Business API.
    *   هذا الرمز **لا يستخدم** للوصول إلى Instagram.
*   **`Webhook URL` و `Verify Token`**: (مشتركان نظرياً، لكن يتم تكوينهما بشكل خاص لـ WhatsApp API) لربط الأحداث الواردة.
*   **رقم الهاتف نفسه**: الرقم الفعلي المعتمد للواتساب.

**الخلاصة لـ WhatsApp:** تبدأ أيضاً بمفاتيح Meta App المشتركة، لكنك تعمل ضمن سياق Meta Business Manager لإنشاء `System User Access Token` و `IDs` **خاصة بـ WhatsApp** والتي تُستخدم حصرياً للوصول إلى WhatsApp.

---

### ملخص التمايز والترابط:

*   **المفاتيح المشتركة (المتغيرات البيئية):**
    *   `META_APP_ID`
    *   `META_APP_SECRET`
    *   `NEXT_PUBLIC_META_REDIRECT_URI` (قد يكون رابطاً واحداً لجميع عمليات OAuth أو روابط مختلفة لخدمات مختلفة لزيادة التحديد)
*   **الـ Access Tokens المتخصصة:**
    *   **Instagram:** `User Access Token` (مرتبط بالمستخدم الذي قام بالربط)
    *   **WhatsApp:** `System User Access Token` (مرتبط بمستخدم نظام لإدارة WABA)
*   **الـ IDs المتخصصة:**
    *   **Instagram:** `Instagram Business Account ID`, `Facebook Page ID` (معرفات الأصول)
    *   **WhatsApp:** `WABA ID`, `Phone Number ID` (معرفات الأصول)

**ما يعنيه هذا لتطبيقك:**

1.  **`.env.local`:** ستكون لديك مفاتيح `META_APP_ID` و `META_APP_SECRET` في ملف `.env.local` الخاص بك.
2.  **Frontend (`settings/page.tsx`):**
    *   عندما يضغط المستخدم "Connect Instagram"، سيبدأ تدفق OAuth الذي يستخدم `META_APP_ID`.
    *   عندما يملأ المستخدم تفاصيل WhatsApp يدوياً، ستتضمن هذه التفاصيل `WABA ID` و `Phone Number ID` و `System User Access Token` (التي يجب أن يكون المستخدم قد حصل عليها مسبقاً من Meta Business Manager).
3.  **Backend (`api/integrations/...`)**:
    *   `instagram/callback`: سيستخدم `META_APP_ID` و `META_APP_SECRET` للحصول على `User Access Token` و `Instagram IDs`، ثم يحفظها في جدول `InstagramAccount`.
    *   `whatsapp/connect`: سيتلقى `WABA ID` و `Phone Number ID` و `System User Access Token` من الـ frontend (الذي أدخله المستخدم)، ويحفظها في جدول `WhatsAppAccount`.

**نعم، أنت بحاجة إلى مفتاحين رئيسيين لـ Meta App، ولكن ستحصل على رموز وصول (Access Tokens) ومعرفات (IDs) فريدة لكل منصة (Instagram و WhatsApp) يجب تخزينها وربطها بشكل منفصل في قاعدة بياناتك.**
